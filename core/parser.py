from typing import List, Tuple, Optional, Dict
from core.ast import ASTNode
# =============================================================================
# Parser Class
# =============================================================================
class Parser:
    """
    The Parser class is responsible for taking a stream of tokens from the
    tokenizer and building an Abstract Syntax Tree (AST) that represents the
    structure of the program.
    """
    # Constants
    KEYWORDS = ['int', 'float', 'void', 'string']

    def __init__(self, tokens: List[Tuple[str, str]]):
        """
        Initializes the Parser with the list of tokens.

        Args:
            tokens (List[Tuple[str, str]]): The list of tokens generated by
                the tokenizer.
        """
        self.tokens = tokens
        self.cursor = 0
        self.current_token: Optional[Tuple[str, str]] = self.tokens[0] if self.tokens else None
        self.global_scope: Dict[str, str] = {}  # Store variables and their types in the global scope

    def advance(self):
        """
        Moves to the next token in the list.
        """
        self.cursor += 1
        if self.cursor < len(self.tokens):
            self.current_token = self.tokens[self.cursor]
        else:
            self.current_token = None  # End of tokens

    def consume(self, expected_type: str) -> str:
        """
        Consumes the current token and checks if it matches the expected type.

        If the token matches, it advances to the next token and returns the
        token's value.  If it doesn't match, it raises a SyntaxError.

        Args:
            expected_type (str): The expected type of the token.

        Returns:
            str: The value of the consumed token.

        Raises:
            SyntaxError: If the current token does not match the expected type.
        """
        if self.current_token and self.current_token[0] == expected_type:
            value = self.current_token[1]
            self.advance()
            return value
        else:
            raise SyntaxError(
                f"Expected {expected_type}, but got {self.current_token}.  Current token is: {self.current_token}"
            )

    def program(self) -> ASTNode:
        """
        Parses the top-level program structure.

        program : statement*

        Returns:
            ASTNode: The AST node representing the program.
        """
        node = ASTNode('Program')
        node.scope = self.global_scope #set the scope for program
        while self.current_token:
            statement_node = self.statement()
            node.add_child(statement_node)
        return node

    def statement(self) -> ASTNode:
        """
        Parses a statement.

        statement : expression_statement
                  | if_statement
                  | while_statement
                  | return_statement
                  | declaration_statement
                  | compound_statement

        Returns:
            ASTNode: The AST node representing the statement.
        """
        if not self.current_token:
            return ASTNode("EmptyStatement") #handle empty
        if self.current_token[0] == 'KEYWORD' and self.current_token[1] == 'if':
            return self.if_statement()
        elif self.current_token[0] == 'KEYWORD' and self.current_token[1] == 'while':
            return self.while_statement()
        elif self.current_token[0] == 'KEYWORD' and self.current_token[1] == 'return':
            return self.return_statement()
        elif self.current_token[0] == 'KEYWORD' and (self.current_token[1] in Parser.KEYWORDS):
            return self.declaration_statement()
        elif self.current_token[0] == 'OPERATOR' and self.current_token[1] == '{':
            return self.compound_statement()
        else:
            return self.expression_statement()

    def expression_statement(self) -> ASTNode:
        """
        Parses an expression statement.

        expression_statement : expression ';'

        Returns:
            ASTNode: The AST node representing the expression statement.
        """
        node = ASTNode('ExpressionStatement')
        expression_node = self.expression()
        node.add_child(expression_node)
        self.consume('OPERATOR')  # Consume the semicolon
        return node

    def if_statement(self) -> ASTNode:
        """
        Parses an if statement.

        if_statement : 'if' '(' expression ')' statement
                     | 'if' '(' expression ')' statement 'else' statement

        Returns:
            ASTNode: The AST node representing the if statement.
        """
        node = ASTNode('IfStatement')
        self.consume('KEYWORD')         # Consume 'if'
        self.consume('OPERATOR')         # Consume '('
        condition_node = self.expression()
        node.add_child(condition_node) # Add condition
        self.consume('OPERATOR')         # Consume ')'
        then_statement = self.statement()
        node.add_child(then_statement)    # Add then statement

        if self.current_token and self.current_token[0] == 'KEYWORD' and self.current_token[1] == 'else':
            self.advance()                # Consume 'else'
            else_statement = self.statement()
            node.add_child(else_statement)  # Add else statement
        return node

    def while_statement(self) -> ASTNode:
        """
        Parses a while statement.

        while_statement : 'while' '(' expression ')' statement

        Returns:
            ASTNode: The AST node representing the while statement.
        """
        node = ASTNode('WhileStatement')
        self.consume('KEYWORD')         # Consume 'while'
        self.consume('OPERATOR')         # Consume '('
        condition_node = self.expression()
        node.add_child(condition_node) # Add condition
        self.consume('OPERATOR')         # Consume ')'
        loop_statement = self.statement()
        node.add_child(loop_statement)    # Add loop statement
        return node

    def return_statement(self) -> ASTNode:
        """
        Parses a return statement.

        return_statement : 'return' expression? ';'

        Returns:
            ASTNode: The AST node representing the return statement.
        """
        node = ASTNode('ReturnStatement')
        self.consume('KEYWORD')         # Consume 'return'
        if self.current_token and self.current_token[0] != 'OPERATOR' or self.current_token[1] != ';':
            expression_node = self.expression()
            node.add_child(expression_node) # Add expression
        self.consume('OPERATOR')         # Consume ';'
        return node

    def declaration_statement(self) -> ASTNode:
        """
        Parses a declaration statement.

        declaration_statement : type_specifier IDENTIFIER (',' IDENTIFIER)* ( '=' expression )? ';'
        """
        node = ASTNode('DeclarationStatement')
        type_specifier = self.type_specifier()  # return the type
        node.value = type_specifier
        node.data_type = type_specifier #store the data type

        identifiers = []
        identifiers.append(self.consume('IDENTIFIER'))  # Consume the first identifier

        while self.current_token and self.current_token[0] == 'OPERATOR' and self.current_token[1] == ',':
            self.advance()  # Consume ','
            identifiers.append(self.consume('IDENTIFIER'))  # Consume subsequent identifiers

        # Create Identifier nodes for each identifier
        for identifier in identifiers:
            identifier_node = ASTNode("Identifier")
            identifier_node.value = identifier
            identifier_node.data_type = type_specifier # Propagate the data type
            node.add_child(identifier_node)
             # Check for duplicate declarations
            if identifier in self.global_scope:
                raise SyntaxError(f"Duplicate declaration of variable '{identifier}'")
            self.global_scope[identifier] = type_specifier  # Store variable and its type

        if self.current_token and self.current_token[0] == 'OPERATOR' and self.current_token[1] == '=':
            self.advance()  # Consume '='
            expression_node = self.expression()
            node.add_child(expression_node)  # Add expression
             # Type checking: Check if the expression type matches the declared variable type
            if expression_node.data_type != type_specifier:
                raise SyntaxError(f"Type mismatch in assignment for variable '{identifiers[0]}'")
        self.consume('OPERATOR')  # Consume ';'
        return node

    def type_specifier(self) -> str:
        """
        Parses a type specifier.

        type_specifier : 'int' | 'float' | 'void' | 'string'

        Returns:
            str: The type specifier.

        Raises:
            SyntaxError: If the type specifier is invalid.
        """
        if self.current_token and self.current_token[0] == 'KEYWORD' and self.current_token[1] in Parser.KEYWORDS:
            type_specifier = self.current_token[1]
            self.advance()
            return type_specifier
        else:
            raise SyntaxError("Invalid type specifier")

    def compound_statement(self) -> ASTNode:
        """
        Parses a compound statement (block).

        compound_statement : '{' statement* '}'

        Returns:
            ASTNode: The AST node representing the compound statement.
        """
        node = ASTNode('CompoundStatement')
        node.scope = {} # Create new scope
        self.consume('OPERATOR')         # Consume '{'
        while self.current_token and self.current_token[0] != 'OPERATOR' or self.current_token[1] != '}':
            statement_node = self.statement()
            node.add_child(statement_node) # Add statement
        self.consume('OPERATOR')         # Consume '}'
        return node

    def expression(self) -> ASTNode:
        """
        Parses an expression.  This is a placeholder for a more complex
        expression parsing logic.  For now, it just handles identifiers,
        integers, and floats.

        expression : term ( ('+' | '-') term )*
        term       : factor ( ('*' | '/') factor )*
        factor     : IDENTIFIER | INTEGER | FLOAT | '(' expression ')'

        Returns:
            ASTNode: The AST node representing the expression.
        """
        return self.additive_expression()

    def additive_expression(self) -> ASTNode:
        """
        Parses additive expressions.
        additive_expression : multiplicative_expression ( ('+' | '-') multiplicative_expression )*
        """
        left = self.multiplicative_expression()
        while self.current_token and self.current_token[0] == 'OPERATOR' and self.current_token[1] in ('+', '-'):
            op = self.current_token[1]
            self.consume('OPERATOR')
            right = self.multiplicative_expression()
            node = ASTNode('BinaryOperator')
            node.value = op

            # Type checking for binary operations
            if left.data_type and right.data_type:
                if left.data_type != right.data_type:
                    raise SyntaxError(f"Type mismatch in additive expression: {left.data_type} {op} {right.data_type}")
                node.data_type = left.data_type # Resulting type is the same as operands

            node.add_child(left)
            node.add_child(right)
            left = node
        return left

    def multiplicative_expression(self) -> ASTNode:
        """
        Parses multiplicative expressions.
        multiplicative_expression : primary_expression ( ('*' | '/') primary_expression )*
        """
        left = self.primary_expression()
        while self.current_token and self.current_token[0] == 'OPERATOR' and self.current_token[1] in ('*', '/'):
            op = self.current_token[1]
            self.consume('OPERATOR')
            right = self.primary_expression()
            node = ASTNode('BinaryOperator')
            node.value = op
             # Type checking for binary operations
            if left.data_type and right.data_type:
                if left.data_type != right.data_type:
                    raise SyntaxError(f"Type mismatch in multiplicative expression: {left.data_type} {op} {right.data_type}")
                node.data_type = left.data_type
            node.add_child(left)
            node.add_child(right)
            left = node
        return left

    def primary_expression(self) -> ASTNode:
        """
        Parses primary expressions.
        primary_expression : IDENTIFIER | INTEGER | FLOAT | STRING | '(' expression ')'
        """
        if self.current_token[0] == 'IDENTIFIER':
            node = ASTNode('Identifier')
            node.value = self.consume('IDENTIFIER')
            #check if the variable is declared
            if node.value not in self.global_scope:
                raise SyntaxError(f"Undeclared variable '{node.value}'")
            node.data_type = self.global_scope[node.value] #get the data type
            return node
        elif self.current_token[0] == 'INTEGER':
            node = ASTNode('IntegerLiteral')
            node.value = self.consume('INTEGER')
            node.data_type = 'int'
            return node
        elif self.current_token[0] == 'FLOAT':
            node = ASTNode('FloatLiteral')
            node.value = self.consume('FLOAT')
            node.data_type = 'float'
            return node
        elif self.current_token[0] == 'STRING':
            node = ASTNode('StringLiteral')
            node.value = self.consume('STRING')
            node.data_type = 'string'
            return node
        elif self.current_token[0] == 'OPERATOR' and self.current_token[1] == '(':
            self.consume('OPERATOR')
            node = self.expression()
            self.consume('OPERATOR')
            return node
        else:
            raise SyntaxError(f"Invalid expression: {self.current_token}")

    def parse(self) -> ASTNode:
        """
        Parses the entire input and returns the root of the AST.
        """
        return self.program()
