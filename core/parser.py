from typing import List, Tuple, Optional, Dict
from core.ast import ASTNode
# =============================================================================
# Parser Class
# =============================================================================
class Parser:
    """
    The Parser class is responsible for taking a stream of tokens from the
    tokenizer and building an Abstract Syntax Tree (AST) that represents the
    structure of the program.
    """
    # Constants
    KEYWORDS = ['int', 'float', 'void', 'string']

    def __init__(self, tokens: List[Tuple[str, str]]):
        """
        Initializes the Parser with the list of tokens.

        Args:
            tokens (List[Tuple[str, str]]): The list of tokens generated by
                the tokenizer.
        """
        self.tokens = tokens
        self.cursor = 0
        self.current_token: Optional[Tuple[str, str]] = self.tokens[0] if self.tokens else None
        self.global_scope: Dict[str, str] = {}  # Store variables and their types in the global scope

    def advance(self):
        """
        Moves to the next token in the list.
        """
        self.cursor += 1
        if self.cursor < len(self.tokens):
            self.current_token = self.tokens[self.cursor]
        else:
            self.current_token = None  # End of tokens

    def consume(self, expected_type: str) -> str:
        """
        Consumes the current token and checks if it matches the expected type.

        If the token matches, it advances to the next token and returns the
        token's value.  If it doesn't match, it raises a SyntaxError.

        Args:
            expected_type (str): The expected type of the token.

        Returns:
            str: The value of the consumed token.

        Raises:
            SyntaxError: If the current token does not match the expected type.
        """
        if self.current_token and self.current_token[0] == expected_type:
            value = self.current_token[1]
            self.advance()
            return value
        else:
            raise SyntaxError(
                f"Expected {expected_type}, but got {self.current_token}.  Current token is: {self.current_token}"
            )

    def program(self) -> ASTNode:
        """
        Parses the top-level program structure.

        program : statement*

        Returns:
            ASTNode: The AST node representing the program.
        """
        node = ASTNode('Program')
        node.scope = self.global_scope #set the scope for program
        while self.current_token:
            statement_node = self.statement()
            node.add_child(statement_node)
        return node

    def statement(self) -> ASTNode:
        """
        Parses a statement.

        statement : expression_statement
                  | if_statement
                  | while_statement
                  | for_statement
                  | return_statement
                  | declaration_statement
                  | compound_statement

        Returns:
            ASTNode: The AST node representing the statement.
        """
        if not self.current_token:
            return ASTNode("EmptyStatement") #handle empty
        if self.current_token[0] == 'KEYWORD' and self.current_token[1] == 'if':
            return self.if_statement()
        elif self.current_token[0] == 'KEYWORD' and self.current_token[1] == 'else':
            # Handle 'else' as part of an invalid context
            raise SyntaxError("Unexpected 'else' without matching 'if'")
        elif self.current_token[0] == 'KEYWORD' and self.current_token[1] == 'while':
            return self.while_statement()
        elif self.current_token[0] == 'KEYWORD' and self.current_token[1] == 'for':
            return self.for_statement() 
        elif self.current_token[0] == 'KEYWORD' and self.current_token[1] == 'return':
            return self.return_statement()
        elif self.current_token[0] == 'KEYWORD' and (self.current_token[1] in Parser.KEYWORDS):
            return self.declaration_statement()
        elif self.current_token[0] == 'OPERATOR' and self.current_token[1] == '{':
            return self.compound_statement()
        else:
            return self.expression_statement()
        

    ## Statement Helper Functions
    def expression_statement(self) -> ASTNode:
        """
        Parses an expression statement.

        expression_statement : expression ';'

        Returns:
            ASTNode: The AST node representing the expression statement.
        """
        node = ASTNode('ExpressionStatement')
        expression_node = self.expression()
        node.add_child(expression_node)
        self.consume('OPERATOR')  # Consume the semicolon
        return node

    def if_statement(self) -> ASTNode:
        """
        Parses an if statement.

        if_statement : 'if' '(' expression ')' statement
                     | 'if' '(' expression ')' statement 'else' statement

        Returns:
            ASTNode: The AST node representing the if statement.
        """
        node = ASTNode('IfStatement')
        self.consume('KEYWORD')         # Consume 'if'
        self.consume('OPERATOR')         # Consume '('
        condition_node = self.expression()
        node.add_child(condition_node) # Add condition
        self.consume('OPERATOR')         # Consume ')'
        then_statement = self.statement()
        node.add_child(then_statement)    # Add then statement

        if self.current_token and self.current_token[0] == 'KEYWORD' and self.current_token[1] == 'else':
            self.consume('KEYWORD')       # Consume 'else'
            else_statement = self.statement()
            node.add_child(else_statement)  # Add else statement
        return node

    def while_statement(self) -> ASTNode:
        """
        Parses a while statement.

        while_statement : 'while' '(' expression ')' statement

        Returns:
            ASTNode: The AST node representing the while statement.
        """
        node = ASTNode('WhileStatement')
        self.consume('KEYWORD')         # Consume 'while'
        self.consume('OPERATOR')         # Consume '('
        condition_node = self.expression()
        node.add_child(condition_node) # Add condition
        self.consume('OPERATOR')         # Consume ')'
        loop_statement = self.statement()
        node.add_child(loop_statement)    # Add loop statement
        return node
    
    def for_statement(self) -> ASTNode:
        """
        Parses a for statement.

        for_statement : 'for' '(' declaration_statement ';' expression ';' counter ')' statement

        Returns:
            ASTNode: The AST node representing the for statement.
        """
        node = ASTNode('ForStatement')
        self.consume('KEYWORD')  # Consume 'for'
        self.consume('OPERATOR')  # Consume '('

        # Parse the declaration statement
        declaration_node = self.declaration_statement()
        node.add_child(declaration_node)

        # Parse the expression (formerly condition)
        expression_node = self.expression()
        node.add_child(expression_node)
        self.consume('OPERATOR')  # Consume ';'

        # Parse the counter (e.g., increment or decrement)
        counter_node = self.expression()
        node.add_child(counter_node)
        self.consume('OPERATOR')  # Consume ')'

        # Parse the body of the for loop
        body_node = self.statement()
        node.add_child(body_node)

        return node

    def return_statement(self) -> ASTNode:
        """
        Parses a return statement.

        return_statement : 'return' expression? ';'

        Returns:
            ASTNode: The AST node representing the return statement.
        """
        node = ASTNode('ReturnStatement')
        self.consume('KEYWORD')         # Consume 'return'
        if self.current_token and self.current_token[0] != 'OPERATOR' or self.current_token[1] != ';':
            expression_node = self.expression()
            node.add_child(expression_node) # Add expression
        self.consume('OPERATOR')         # Consume ';'
        return node

    def declaration_statement(self) -> ASTNode:
        """
        Parses a declaration statement.

        declaration_statement : type_specifier IDENTIFIER (',' IDENTIFIER)* ( '=' expression )? ';'
        """
        node = ASTNode('DeclarationStatement')
        type_specifier = self.type_specifier()  # return the type
        node.value = type_specifier
        node.data_type = type_specifier #store the data type

        identifiers = []
        identifiers.append(self.consume('IDENTIFIER'))  # Consume the first identifier

        while self.current_token and self.current_token[0] == 'OPERATOR' and self.current_token[1] == ',':
            self.advance()  # Consume ','
            identifiers.append(self.consume('IDENTIFIER'))  # Consume subsequent identifiers

        # Create Identifier nodes for each identifier
        for identifier in identifiers:
            identifier_node = ASTNode("Identifier")
            identifier_node.value = identifier
            identifier_node.data_type = type_specifier # Propagate the data type
            node.add_child(identifier_node)
             # Check for duplicate declarations
            if identifier in self.global_scope:
                raise SyntaxError(f"Duplicate declaration of variable '{identifier}'")
            self.global_scope[identifier] = type_specifier  # Store variable and its type

        if self.current_token and self.current_token[0] == 'OPERATOR' and self.current_token[1] == '=':
            self.advance()  # Consume '='
            expression_node = self.expression()
            node.add_child(expression_node)  # Add expression
             # Type checking: Check if the expression type matches the declared variable type
            if expression_node.data_type != type_specifier:
                raise SyntaxError(f"Type mismatch in assignment for variable '{identifiers[0]}'")
        self.consume('OPERATOR')  # Consume ';'
        return node

    def type_specifier(self) -> str:
        """
        Parses a type specifier.

        type_specifier : 'int' | 'float' | 'void' | 'string'

        Returns:
            str: The type specifier.

        Raises:
            SyntaxError: If the type specifier is invalid.
        """
        if self.current_token and self.current_token[0] == 'KEYWORD' and self.current_token[1] in Parser.KEYWORDS:
            type_specifier = self.current_token[1]
            self.advance()
            return type_specifier
        else:
            raise SyntaxError("Invalid type specifier")

    def compound_statement(self) -> ASTNode:
        """
        Parses a compound statement (block).

        compound_statement : '{' statement* '}'

        Returns:
            ASTNode: The AST node representing the compound statement.
        """
        node = ASTNode('CompoundStatement')
        node.scope = {} # Create new scope
        self.consume('OPERATOR')         # Consume '{'
        while self.current_token and self.current_token[0] != 'OPERATOR' or self.current_token[1] != '}':
            statement_node = self.statement()
            node.add_child(statement_node) # Add statement
        self.consume('OPERATOR')         # Consume '}'
        return node

    def expression(self) -> ASTNode:
        """
        Parses an expression.

        expression : logical_or_expression

        Returns:
            ASTNode: The AST node representing the expression.
        """
        return self.logical_or_expression()
    
    def logical_or_expression(self) -> ASTNode:
        """
        Parses logical OR expressions.

        logical_or_expression : logical_and_expression ( '||' logical_and_expression )*
        """
        left = self.logical_and_expression()
        while self.current_token and self.current_token[0] == 'OPERATOR' and self.current_token[1] == '||':
            op = self.consume('OPERATOR')
            right = self.logical_and_expression()
            node = ASTNode('LogicalOperator')
            node.value = op
            node.data_type = 'bool'  # Logical operations result in boolean type
            node.add_child(left)
            node.add_child(right)
            left = node
        return left

    def logical_and_expression(self) -> ASTNode:
        """
        Parses logical AND expressions.

        logical_and_expression : equality_expression ( '&&' equality_expression )*
        """
        left = self.equality_expression()
        while self.current_token and self.current_token[0] == 'OPERATOR' and self.current_token[1] == '&&':
            op = self.consume('OPERATOR')
            right = self.equality_expression()
            node = ASTNode('LogicalOperator')
            node.value = op
            node.data_type = 'bool'
            node.add_child(left)
            node.add_child(right)
            left = node
        return left

    def equality_expression(self) -> ASTNode:
        """
        Parses equality expressions.

        equality_expression : relational_expression ( ('==' | '!=') relational_expression )*
        """
        left = self.relational_expression()
        while self.current_token and self.current_token[0] == 'OPERATOR' and self.current_token[1] in ('==', '!='):
            op = self.consume('OPERATOR')
            right = self.relational_expression()
            node = ASTNode('EqualityOperator')
            node.value = op
            node.data_type = 'bool'
            node.add_child(left)
            node.add_child(right)
            left = node
        return left

    def relational_expression(self) -> ASTNode:
        """
        Parses relational expressions.

        relational_expression : additive_expression ( ('<' | '>' | '<=' | '>=') additive_expression )*
        """
        left = self.additive_expression()
        while self.current_token and self.current_token[0] == 'OPERATOR' and self.current_token[1] in ('<', '>', '<=', '>='):
            op = self.consume('OPERATOR')
            right = self.additive_expression()
            node = ASTNode('RelationalOperator')
            node.value = op
            node.data_type = 'bool'
            node.add_child(left)
            node.add_child(right)
            left = node
        return left
    def additive_expression(self) -> ASTNode:
        """
        Parses additive expressions.
        additive_expression : multiplicative_expression ( ('+' | '-') multiplicative_expression )*
        """
        left = self.multiplicative_expression()
        while self.current_token and self.current_token[0] == 'OPERATOR' and self.current_token[1] in ('+', '-'):
            op = self.current_token[1]
            self.consume('OPERATOR')
            right = self.multiplicative_expression()
            node = ASTNode('BinaryOperator')
            node.value = op

            # Type checking for binary operations
            if left.data_type and right.data_type:
                if left.data_type != right.data_type:
                    raise SyntaxError(f"Type mismatch in additive expression: {left.data_type} {op} {right.data_type}")
                node.data_type = left.data_type # Resulting type is the same as operands

            node.add_child(left)
            node.add_child(right)
            left = node
        return left

    def multiplicative_expression(self) -> ASTNode:
        """
        Parses multiplicative expressions.
        multiplicative_expression : primary_expression ( ('*' | '/') primary_expression )*
        """
        left = self.primary_expression()
        while self.current_token and self.current_token[0] == 'OPERATOR' and self.current_token[1] in ('*', '/'):
            op = self.current_token[1]
            self.consume('OPERATOR')
            right = self.primary_expression()
            node = ASTNode('BinaryOperator')
            node.value = op
             # Type checking for binary operations
            if left.data_type and right.data_type:
                if left.data_type != right.data_type:
                    raise SyntaxError(f"Type mismatch in multiplicative expression: {left.data_type} {op} {right.data_type}")
                node.data_type = left.data_type
            node.add_child(left)
            node.add_child(right)
            left = node
        return left

    def primary_expression(self) -> ASTNode:
        """
        Parses primary expressions.

        primary_expression : IDENTIFIER | INTEGER | FLOAT | STRING | '(' expression ')' | '!' primary_expression
        """
        if self.current_token[0] == 'OPERATOR' and self.current_token[1] == '!':
            self.consume('OPERATOR')  # Consume '!'
            operand = self.primary_expression()
            node = ASTNode('LogicalNot')
            node.value = '!'
            node.data_type = 'bool'
            node.add_child(operand)
            return node
        elif self.current_token[0] == 'IDENTIFIER':
            node = ASTNode('Identifier')
            node.value = self.consume('IDENTIFIER')
            if node.value not in self.global_scope:
                raise SyntaxError(f"Undeclared variable '{node.value}'")
            node.data_type = self.global_scope[node.value]
            return node
        elif self.current_token[0] == 'INTEGER':
            node = ASTNode('IntegerLiteral')
            node.value = self.consume('INTEGER')
            node.data_type = 'int'
            return node
        elif self.current_token[0] == 'FLOAT':
            node = ASTNode('FloatLiteral')
            node.value = self.consume('FLOAT')
            node.data_type = 'float'
            return node
        elif self.current_token[0] == 'STRING':
            node = ASTNode('StringLiteral')
            node.value = self.consume('STRING')
            node.data_type = 'string'
            return node
        elif self.current_token[0] == 'OPERATOR' and self.current_token[1] == '(':
            self.consume('OPERATOR')  # Consume '('
            node = self.expression()
            self.consume('OPERATOR')  # Consume ')'
            return node
        else:
            raise SyntaxError(f"Invalid expression: {self.current_token}")

    def parse(self) -> ASTNode:
        """
        Parses the entire input and returns the root of the AST.
        """
        return self.program()
